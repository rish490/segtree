class segtree{ 
    vector<ll>tree;
    vector<ll>lazy;
    public:
    segtree(ll N){
        tree.assign(4*N,0);
        lazy.assign(4*N,0);
    }
void build(ll node, ll st, ll en, vector<ll>&arr){ 
    lazy[node] = 0;
    if(st == en){
        tree[node] = arr[st];
        return;
    }
 
    ll mid = (st+en)/2;
    build(2*node+1, st, mid, arr);
    build(2*node + 2, mid+1, en, arr);
}
 
void lazyPropogation(ll node, ll st, ll en){
    if(!lazy[node]) return;
    if(st != en){
        lazy[2*node+1] += lazy[node];
        lazy[2*node+2] += lazy[node];
    }
    else tree[node] = (tree[node] + lazy[node]);
    lazy[node] = 0;
}
 
ll query(ll node, ll st, ll en, ll l, ll r){ 
    lazyPropogation(node, st, en);
    if(st > r || en < l)
        return 0;
    
    if(l <= st && r >= en) 
        return tree[node];
    
    ll mid = (st + en)/2;
 
    ll q1 = query(2*node+1, st, mid, l, r);
    ll q2 = query(2*node + 2, mid+1, en, l, r);
 
    return q1 + q2;
}
 
void update(ll node, ll st, ll en, ll l, ll r, ll val){
    lazyPropogation(node, st, en);
    if(st > r || en < l)
        return;
    
    if(l <= st && r >= en){
        lazy[node] += val;
        return;
    }
 
    ll mid = (st + en)/2;
    update(2*node+1, st, mid, l, r, val);
    update(2*node + 2, mid+1, en, l, r, val);
}
};
