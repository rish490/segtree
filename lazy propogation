class Lsegtree{
public:
    vector<ll>st,lazy,a;
    int n;
    Lsegtree(vector<ll>&b){
        a=b;
        n=a.size();
        st.resize(4*n);
        lazy.resize(4*n);
        fill(lazy.begin(),lazy.end(),0);
        build(0,n-1,0);
    }
    void build(int ss,int se,int si){
        if(ss==se){
            st[si]=a[ss];
            return;
        }
        int mid=(ss+se)/2;
        build(ss,mid,2*si+1);
        build(mid+1,se,2*si+2);
        st[si]=st[2*si+1]+st[2*si+2];
        return;
    }
    void check(int si,int ss,int se){
        if(lazy[si]!=0){
            if(lazy[si]%2==1){
                st[si]=(se-ss+1)-st[si];
            }
            
            if(ss!=se){
                lazy[2*si+1]+=lazy[si];
                lazy[2*si+2]+=lazy[si];
            }
            lazy[si]=0;
        }
    }
    ll getsum(int ss,int se,int qs,int qe,int si){
        check(si,ss,se);
        //no overlap
        if(ss>qe || qs>se||ss>se) return 0;
        //totally inside
        if(ss>=qs && se<=qe) return st[si];
        int mid=(ss+se)/2;
        return getsum(ss,mid,qs,qe,2*si+1)+getsum(mid+1,se,qs,qe,2*si+2);
    }
    void update(int ss,int se,int qs,int qe,int si,int val){
        check(si,ss,se);
        if(ss>qe || qs>se||ss>se) return;
        if(ss>=qs && se<=qe){
            lazy[si]+=val;
            check(si,ss,se);
            return;
        }
        int mid=(ss+se)/2;
        update(ss,mid,qs,qe,2*si+1,val);
        update(mid+1,se,qs,qe,2*si+2,val);
        st[si]=st[2*si+1]+st[2*si+2];
    }
};
